---
title: Redis
toc: true
date: 2022-05-13 08:46:32
tags:
---

## 基础架构

- 1.访问框架
  - socket 网络访问
  - 请求解析
- 2.操作模块
  - 基于不同类型 value 的操作模块
- 3.索引模块
- 4.存储模块
  - 持久化模块: RDB, AOF
  - 分配器
- 5.高可用集群支撑模块
  - 主从复制
  - 哨兵机制
- 5.高可扩展集群支撑模块
  - 数据分片

## 线程模型

- Redis 在处理网络请求是使用单线程模型，并通过 IO 多路复用来提高并发。但是在其他模块，比如：持久化，会使用多个线程。
- 文件事件处理器: 采用 IO 多路复用机制同时监听多个 socket
  - 多个 socket
  - IO 多路复用程序
  - 文件事件分派器
  - 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
- 为啥 Redis 单线程模型也能效率这么高？
  - 纯内存操作
  - 核心是基于非阻塞的 IO 多路复用机制
  - 单线程反而避免了多线程的频繁上下文切换问题

## 持久化

### RDB

- fork 子进程生成数据快照,>=5min 一次
- 宕机重启会丢失最近 5 分钟的数据。
- 如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

### AOF

- 以 append-only 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集
- AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。
- AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。
- AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常 适合做灾难性的误删除的紧急恢复。
- AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低

### RDB 和 AOF 到底该如何选择

- 不要仅仅使用 RDB，因为那样会导致你丢失很多数据；
- 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；
- Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

### 一致性哈希算法

- 一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中 K 是关键字的数量，n 是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。
- 一致哈希也可用于实现健壮缓存来减少大型 Web 应用中系统部分失效带来的负面影响
- 需求: 当增加或减少一台缓存服务器时尽可能减少资源 hash 映射变化
- 实现
  - 一致哈希将每个对象映射到圆环边上的一个点，系统再将可用的节点机器映射到圆环的不同位置。查找某个对象对应的机器时，需要用一致哈希算法计算得到对象对应圆环边上位置，沿着圆环边上查找直到遇到某个节点机器，这台机器即为对象应该保存的位置。
  - 当删除一台节点机器时，这台机器上保存的所有对象都要移动到下一台机器。添加一台机器到圆环边上某个点时，这个点的下一台机器需要将这个节点前对应的对象移动到新机器上。更改对象在节点机器上的分布可以通过调整节点机器的位置来实现。
- 哈希算法对比
  - 普通哈希算法: 使用 MD5 算法,分布均匀,但该算法使用节点数取余的方法，强依赖 node 的数目,node 数量变化时需要大量数据迁移
  - 一致性哈希: 解决了节点变化导致的数据迁移问题，但是，数据项分布的均匀性很差。
  - 改进 – 虚节点: 通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。

## 数据结构

- redis 的跳表知道吗，为什么不用红黑树
- Redis hash、zset 数据结构？跳表是怎么构建的？

### 支持的类型

- String
  - SDS(简单动态字符串)
- List
  - 双向链表
  - 压缩列表
- Hash
  - 压缩列表
  - 哈希表
- Set
  - 哈希表
  - 整数数组
- Sorted Set
  - 压缩列表
  - 跳表

### 底层数据结构

- 简单动态字符串(SDS)
- 双向链表
  - 查找 O(N),修改 O(1)
- 整数数组
  - 查找 O(1),修改 O(N)
- 哈希表
  - 查找 O(1),修改 O(1)
- 压缩列表
  - 压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。
  - 查找头尾 O(1),其他 O(N)
- 跳表
  - 跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位
  - 查找 O(logN)

### 键和值用什么结构组织？

- 全局哈希表,查找 O(1)
- 哈希冲突
  - 链表存储,查找 O(N)
- rehash
  - 使用两个全局哈希表：哈希表 1 和哈希表 2
    - 1.给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
    - 2.把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
    - 3.释放哈希表 1 的空间。
- 渐进式 rehash
  - 第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries
  - 渐进式 rehash 时对 value 的增删改查都会在两个哈希表上执行，所以才能保证数据不会出错，比如查询操作会先查哈希表 1,查不到再查哈希表 2。其他类似。

## 集群

- redis 集群是怎么实现的，说一下一致性 hash
- Redis Cluster？其他开源集群方案？
- Redis Cluster 是如何进行扩容的？

### 主从复制

- 一主多从，主负责写，并且将数据复制到其它的 Slave 节点，从节点负责读。
- Redis 默认采用异步方式复制数据到 Slave Node，同时 Slave Node 会周期性地确认自己每次复制的数据量
  - 网络通畅: Master 会持续向 Slave 推送命令
  - 网络问题、超时等中断: slave 尝试部分同步（partial resynchronization）
  - 当部分同步不可用时，Slave 会请求全量同步

### 哨兵 Sentinel

- 集群监控：负责监控 Redis Master 和 Slave 进程是否正常工作。
- 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 故障转移：如果 Master node 挂掉了，会自动转移到 Slave node 上。
- 配置中心：如果故障转移发生了，通知 client 客户端新的 Master 地址。
- 核心知识
  - 哨兵至少需要 3 个实例，来保证自己的健壮性。
  - 哨兵 + Redis 主从的部署架构，是 不保证数据零丢失 的，只能保证 Redis 集群的高可用性。
  - 对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。
  - 哨兵的个数与集群节点个数无关，每个哨兵都会 Check 所有节点
  - 当启用哨兵后，客户端的连接是通过哨兵连接到 Node 的
- Slave 选主算法
  - 按照 Slave 优先级进行排序，Slave Priority 越低，优先级就越高。
  - 如果 Slave Priority 相同，那么看 Replica Offset，哪个 Slave 复制了越多的数据，Offset 越靠后，优先级就越高。
  - 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 Slave。

### Redis Cluster

- Redis Cluster 是一种服务器 Sharding 技术，提供内置的高可用支持,集成了 主从复制 和 哨兵 的功能
  - 高性能：在 Cluster 集群中没有代理，主从之间使用异步复制，并且不会对 Key 进行合并操作；
  - 可接受的写入安全：当客户端连接到 majority master 时集群尽最大努力保留所有客户端的写操作。
  - 可用性：NODE_TIMEOUT 时间后进行故障转移;副本迁移（replicas migration），当 master 没有 slave 时，可从其他 master 下重新分配一个 slave
- 内部节点通信
  - Cluster Bus
  - Redis 维护集群元数据采用 gossip 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。
    - 优点: 更新分散
    - 缺点: 元数据的更新有延时
- 寻址算法
  - Redis Cluster 有固定的 16384 个 Hash Slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 Hash Slot。
  - Keys hash tags 可以破坏上述的分配规则，Hash tags 是一种保证多个键被分配到同一个槽位的方法。
- 重定向
  - MOVED: 请求的 slot 永久的由另一个节点提供服务
  - ASK: 仅代表将当前查询重定向到指定节点，不影响后续查询。(在 Redis Cluster 迁移的时候会用到 ASK 重定向)
  - Redis Cluster 的迁移是以槽位单位的，一个槽位从节点 A 迁移到节点 B 需要经过以下步骤：
    - 1.节点 A 将待迁移 slot 设置为 MIGRATING 状态，将 B 节点 slot 设置为 IMPORTING 状态
    - 2.A 获取 slot 中的 key，逐个调用 MIGRATE 命令
    - 3.MIGRATE 会将特定的 key 从 A 迁移到 B，这个过程是原子操作（A、B 均会进行加锁）
- 容错能力
  - 判断心跳: header + gossip 消息
- 故障检测:
  - NODE flags 标识: 不可达 -> PFAIL -> FAIL -> 可达 -> 清除 NODE flags

## 分布式锁

- 数据库实现
- ZooKeeper 实现
- Redis 实现

## 缓存

### 缓存击穿

### 缓存穿透

### 缓存雪崩

- redis setnx + expire 有什么缺点，如何优化
- 并发修改数据库并回写 Redis 如何保证数据一致性？
- Redis 线程模型？持久化方案？

# memcache




## 参考资料
> - []()
> - []()
